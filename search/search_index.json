{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ro-Lib Ro-Lib helps and encourages developers to use streamline design patterns in their code. It has all the things you need to make better and more performant games. Start here: Getting Started","title":"Home"},{"location":"#ro-lib","text":"Ro-Lib helps and encourages developers to use streamline design patterns in their code. It has all the things you need to make better and more performant games. Start here: Getting Started","title":"Ro-Lib"},{"location":"Api/","text":"lib Houses all the components of Ro-Lib. Contains: Chain Command Factory Observer Singleton State Strategy All patterns are classes. When calling a method you should use : instead use . -- DONT chain : add () state : set () Strategy . new () -- DO chain . set () state . set () Strategy () Chain First, you add handlers to the chain. Each handler should return a boolean if it succeeds. Then when executing, it calls each handler one step at a time. If any returns false, it will warn. Chain or chain of responsibility is used often for checking and auth. Chain.new Chain.new(chain: {[number]: function}?, shouldWarn: boolean?): Chain Creates a new chain. shouldWarn is for when a chain fails, if set to true it will warn. Defualts to false. A Chain can be made like this: local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain1 = Chain () -- Or local chain2 = Chain ({ function () end , }) Chain.add Chain.add(handler: function, index: number?): self Adds a new handler to the chain. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () chain . add ( function () print ( \"Hello world!\" ) end ) -- When the chain is called it will print! Chain.execute Chain.execute(...any): boolean Executes the current chain, warns if any handler returns false. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () local res = true chain . add ( function () res = false -- Se we dont get a warn return true end ) -- You could use chain() here chain . execute () print ( res ) -> false Command Register some functions and then later call them by name. It can be very helpful when having lots of functions bound to one object. Command.new Command.new(commands: {[string]: function}?): Command Creates a new command. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) Command . new () -- Or Command ({ Name = function end }) Command.add Command.add(command: function, name: string) Adds a new handler to the command. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function () print ( \"Hello world!\" ) end , \"Hello\" ) -- When the Hello handler is called it will print! Command.execute Command.execute(name: string, ...any): any Calls the specified handler. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function ( arg ) print ( arg ) end , \"Hello\" ) command . execute ( \"Hello\" , \"Hello world!\" ) Factory Create a enum with corresponding name and function. This is what a defualt factory looks like: local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Support = 1 , Ticket = 2 , } local funcs = { Support = function () print ( \"Support!\" ) end , Ticket = function () print ( \"Ticket!\" ) end , } local factory = Factory . new ( enum , funcs ) Factory.new Factory.new(enum: {[string]: number}, factories: {[string]: function}): Factory Creates a new factory local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Dev = 1 , Mod = 2 , } local funcs = { Dev = function ( class ) print ( \"Develper!\" ) class . Name = \"Developer\" end , Mod = function ( class ) print ( \"Moderator!\" ) class . Name = \"Moderator\" end , } Factory . new ( enum , funcs ) Factory.create Factory.create(type: string | number, ...any) Creates a new class from callback with given name or enum index. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Dev = 1 , Mod = 2 , }, { Dev = function ( class ) class . Name = \"Developer\" end , Mod = function ( class ) class . Name = \"Moderator\" end , }) factory . create ( \"Dev\" ) -> { Name = \"Developer\" } -- Or factory . create ( 2 ) -> { Name = \"Moderator\" } Factory.rule Factory.rule(rule: {[number]: function}?) Sets the current rules, useful when you dont want to check arguments your self. The rules are just a table, each index will be called with argument of that index and should return true or false. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Hello = 1 }, { Hello = function ( class , name ) class . Message = \"Hello, \" .. name end , }) factory . rule ({ Factory . Type . string , }) -- Or you can use t by osyrisrblx: https://github.com/osyrisrblx/t factory . rule ({ t . string , }) -- Will error factory . create ( 1 , 10 ) factory . create ( 1 , nil ) factory . create ( 1 , workspace ) -- WON'T error factory . create ( 1 , \"HawDevelopment\" ) factory . create ( 1 , \"Elttob\" ) factory . create ( 1 , \"Berezaa\" ) Factory.base Factory.base(base: {[string]: any}) Sets the current base. A base is just the base class of any class created. You can also use Factory.Argument for setting arguments given. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Test = 1 }, { Test = function ( class ) -- Wont do anything end , }) factory . base ({ Name = Factory . Argument ( 1 ), Age = 13 , Skill = \"Scripting\" , }) -- Base can be used for repetative things factory . create ( 1 , \"HawDevelopment\" ) -> { Name = \"HawDevelopment\" , Age = 13 , Skill = \"Scripting\" } Observer You probably know signals. Observers work mostly in the same way, the only difference is that you have many \"watchers\" bound and you can many underlying types. Types are like sub observer. So this is what a observer could look like: function function Sub: function function Observer.new Observer.new(watcher: {[any]: function}?): Observer Creates a new observer. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) Observer . new () -- Or Observer ({ function () end , }) Observer.add Observer.add(watcher: function, type: string?) Adds a new watcher, you can also give it a type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () end ) -- Or observer . add ( function () end , \"Sub\" ) Observer.fire Observer.fire(type: string | \"All\" | nil, ...any) Fires observer, if a type is given that isnt \"All\" it will only call watchers in that type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () print ( \"1\" ) end ) observer . add ( function () print ( \"2\" ) end , \"Sub\" ) observer . fire () -- \"1\" will print observer . fire ( \"Sub\" ) -- \"2\" will print Singleton Would ever need more than one round? Using singleton you can create one class and then use it all over your program, no need to check if it exists. It doesn't create the class before you call the get method for the first time. Singleton.new Singleton.new(constructor: function | table): Singleton Creates a new singleton. The constructor can be a function or a class with a .new funtion. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) Singleton . new ( function () end ) -- Or Singleton ({ new = function () end }) Singleton.get Singleton.get(): any Gets the current storring class of the singleton, if it hasnt been created it will call the constructor. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) -- Havent been creating so it calls the constructor local ret = singleton . get () -- Returns the same table print ( ret == singleton . get ()) -> true Singleton.destroy Singleton.destroy() Destroys the current object stored. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) local ret = singleton . get () singleton . destroy () print ( ret == singleton . get ()) -> false State Sometimes it can be hard to manage player state. If you have ever sat down and written if statements for hours, this is for you. State.new State.new(defualt: any?, observer: Observer): State Creates a new state. If an obsever is given, it will be used instead of creating a new one. local lib = require ( path . to . lib ) local State = require ( lib . State ) State . new () -- Or State ( \"Hello\" , Observer . new ()) State.observer State.observer(observer: Observer) Sets the current observer. local lib = require ( path . to . lib ) local State = require ( lib . State ) local Observer = require ( lib . Observer ) local state = State . new () state . observer ( Observer . new ()) State.bind State.bind(callback: function, type: string?) Binds the callback to the internal observer of the state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . bind ( function ( arg ) print ( arg ) end ) state . set ( \"Hello world\" ) -- prints \"Hello world!\" -- You can also bind to a specific type state . bind ( function ( arg ) print ( arg ) end , \"Function 2\" ) state . set ( \"Number 2!\" , \"Function 2\" ) -- prints \"Number 2!\" State.set State.set(state: any, type: string?) Sets the current state, it will also call the current observer with the new state. If a type is given, it will only call functions bound to that type. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Hello world\" ) print ( state . get ()) -> \"Hello world!\" State.get State.get(): any Returns the current set state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Whats up?\" ) print ( state . get () == \"Whats up?\" ) -> true Strategy Have you ever had different changing selections that require a specific function? With Strategy you register functions with a specific name, the later set the strategy and when it's called it will execute the function with the corresponding name. Especially useful for changing powers. Strategy.new Strategy.new(handles: {[string]: function}, start: string): Strategy Creates a new strategy. If start isnt given it will defualt to the first index. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) Strategy . new () -- Or Strategy ({ Name = function () end }, \"Name\" ) Strategy.add Strategy.add(handler: function, name: string) Adds a handler to the list of handlers in the strategy. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () end , \"Name\" ) Strategy.set Strategy.set(name: string | State) Sets the current strategy. State If a state is given, it will get the current state and set that as the strategy, and NOT update the strategy when the state updates. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local State = require ( lib . State ) local strategy = Strategy . new () strategy . add ( function ( arg ) print ( arg ) end , \"Hello\" ) strategy . set ( \"Hello\" ) -- Is the same as local state = State . new () state . set ( \"Hello\" ) strategy . set ( state ) Strategy.call Strategy.call(...any): any Calls the current set strategy with given args. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () return 1 + 1 end , \"Plus\" ) strategy . set ( \"Plus\" ) print ( strategy . call ()) -> 2","title":"Api"},{"location":"Api/#lib","text":"Houses all the components of Ro-Lib. Contains: Chain Command Factory Observer Singleton State Strategy All patterns are classes. When calling a method you should use : instead use . -- DONT chain : add () state : set () Strategy . new () -- DO chain . set () state . set () Strategy ()","title":"lib"},{"location":"Api/#chain","text":"First, you add handlers to the chain. Each handler should return a boolean if it succeeds. Then when executing, it calls each handler one step at a time. If any returns false, it will warn. Chain or chain of responsibility is used often for checking and auth.","title":"Chain"},{"location":"Api/#chainnew","text":"Chain.new(chain: {[number]: function}?, shouldWarn: boolean?): Chain Creates a new chain. shouldWarn is for when a chain fails, if set to true it will warn. Defualts to false. A Chain can be made like this: local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain1 = Chain () -- Or local chain2 = Chain ({ function () end , })","title":"Chain.new"},{"location":"Api/#chainadd","text":"Chain.add(handler: function, index: number?): self Adds a new handler to the chain. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () chain . add ( function () print ( \"Hello world!\" ) end ) -- When the chain is called it will print!","title":"Chain.add"},{"location":"Api/#chainexecute","text":"Chain.execute(...any): boolean Executes the current chain, warns if any handler returns false. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () local res = true chain . add ( function () res = false -- Se we dont get a warn return true end ) -- You could use chain() here chain . execute () print ( res ) -> false","title":"Chain.execute"},{"location":"Api/#command","text":"Register some functions and then later call them by name. It can be very helpful when having lots of functions bound to one object.","title":"Command"},{"location":"Api/#commandnew","text":"Command.new(commands: {[string]: function}?): Command Creates a new command. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) Command . new () -- Or Command ({ Name = function end })","title":"Command.new"},{"location":"Api/#commandadd","text":"Command.add(command: function, name: string) Adds a new handler to the command. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function () print ( \"Hello world!\" ) end , \"Hello\" ) -- When the Hello handler is called it will print!","title":"Command.add"},{"location":"Api/#commandexecute","text":"Command.execute(name: string, ...any): any Calls the specified handler. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function ( arg ) print ( arg ) end , \"Hello\" ) command . execute ( \"Hello\" , \"Hello world!\" )","title":"Command.execute"},{"location":"Api/#factory","text":"Create a enum with corresponding name and function. This is what a defualt factory looks like: local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Support = 1 , Ticket = 2 , } local funcs = { Support = function () print ( \"Support!\" ) end , Ticket = function () print ( \"Ticket!\" ) end , } local factory = Factory . new ( enum , funcs )","title":"Factory"},{"location":"Api/#factorynew","text":"Factory.new(enum: {[string]: number}, factories: {[string]: function}): Factory Creates a new factory local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Dev = 1 , Mod = 2 , } local funcs = { Dev = function ( class ) print ( \"Develper!\" ) class . Name = \"Developer\" end , Mod = function ( class ) print ( \"Moderator!\" ) class . Name = \"Moderator\" end , } Factory . new ( enum , funcs )","title":"Factory.new"},{"location":"Api/#factorycreate","text":"Factory.create(type: string | number, ...any) Creates a new class from callback with given name or enum index. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Dev = 1 , Mod = 2 , }, { Dev = function ( class ) class . Name = \"Developer\" end , Mod = function ( class ) class . Name = \"Moderator\" end , }) factory . create ( \"Dev\" ) -> { Name = \"Developer\" } -- Or factory . create ( 2 ) -> { Name = \"Moderator\" }","title":"Factory.create"},{"location":"Api/#factoryrule","text":"Factory.rule(rule: {[number]: function}?) Sets the current rules, useful when you dont want to check arguments your self. The rules are just a table, each index will be called with argument of that index and should return true or false. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Hello = 1 }, { Hello = function ( class , name ) class . Message = \"Hello, \" .. name end , }) factory . rule ({ Factory . Type . string , }) -- Or you can use t by osyrisrblx: https://github.com/osyrisrblx/t factory . rule ({ t . string , }) -- Will error factory . create ( 1 , 10 ) factory . create ( 1 , nil ) factory . create ( 1 , workspace ) -- WON'T error factory . create ( 1 , \"HawDevelopment\" ) factory . create ( 1 , \"Elttob\" ) factory . create ( 1 , \"Berezaa\" )","title":"Factory.rule"},{"location":"Api/#factorybase","text":"Factory.base(base: {[string]: any}) Sets the current base. A base is just the base class of any class created. You can also use Factory.Argument for setting arguments given. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Test = 1 }, { Test = function ( class ) -- Wont do anything end , }) factory . base ({ Name = Factory . Argument ( 1 ), Age = 13 , Skill = \"Scripting\" , }) -- Base can be used for repetative things factory . create ( 1 , \"HawDevelopment\" ) -> { Name = \"HawDevelopment\" , Age = 13 , Skill = \"Scripting\" }","title":"Factory.base"},{"location":"Api/#observer","text":"You probably know signals. Observers work mostly in the same way, the only difference is that you have many \"watchers\" bound and you can many underlying types. Types are like sub observer. So this is what a observer could look like: function function Sub: function function","title":"Observer"},{"location":"Api/#observernew","text":"Observer.new(watcher: {[any]: function}?): Observer Creates a new observer. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) Observer . new () -- Or Observer ({ function () end , })","title":"Observer.new"},{"location":"Api/#observeradd","text":"Observer.add(watcher: function, type: string?) Adds a new watcher, you can also give it a type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () end ) -- Or observer . add ( function () end , \"Sub\" )","title":"Observer.add"},{"location":"Api/#observerfire","text":"Observer.fire(type: string | \"All\" | nil, ...any) Fires observer, if a type is given that isnt \"All\" it will only call watchers in that type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () print ( \"1\" ) end ) observer . add ( function () print ( \"2\" ) end , \"Sub\" ) observer . fire () -- \"1\" will print observer . fire ( \"Sub\" ) -- \"2\" will print","title":"Observer.fire"},{"location":"Api/#singleton","text":"Would ever need more than one round? Using singleton you can create one class and then use it all over your program, no need to check if it exists. It doesn't create the class before you call the get method for the first time.","title":"Singleton"},{"location":"Api/#singletonnew","text":"Singleton.new(constructor: function | table): Singleton Creates a new singleton. The constructor can be a function or a class with a .new funtion. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) Singleton . new ( function () end ) -- Or Singleton ({ new = function () end })","title":"Singleton.new"},{"location":"Api/#singletonget","text":"Singleton.get(): any Gets the current storring class of the singleton, if it hasnt been created it will call the constructor. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) -- Havent been creating so it calls the constructor local ret = singleton . get () -- Returns the same table print ( ret == singleton . get ()) -> true","title":"Singleton.get"},{"location":"Api/#singletondestroy","text":"Singleton.destroy() Destroys the current object stored. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) local ret = singleton . get () singleton . destroy () print ( ret == singleton . get ()) -> false","title":"Singleton.destroy"},{"location":"Api/#state","text":"Sometimes it can be hard to manage player state. If you have ever sat down and written if statements for hours, this is for you.","title":"State"},{"location":"Api/#statenew","text":"State.new(defualt: any?, observer: Observer): State Creates a new state. If an obsever is given, it will be used instead of creating a new one. local lib = require ( path . to . lib ) local State = require ( lib . State ) State . new () -- Or State ( \"Hello\" , Observer . new ())","title":"State.new"},{"location":"Api/#stateobserver","text":"State.observer(observer: Observer) Sets the current observer. local lib = require ( path . to . lib ) local State = require ( lib . State ) local Observer = require ( lib . Observer ) local state = State . new () state . observer ( Observer . new ())","title":"State.observer"},{"location":"Api/#statebind","text":"State.bind(callback: function, type: string?) Binds the callback to the internal observer of the state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . bind ( function ( arg ) print ( arg ) end ) state . set ( \"Hello world\" ) -- prints \"Hello world!\" -- You can also bind to a specific type state . bind ( function ( arg ) print ( arg ) end , \"Function 2\" ) state . set ( \"Number 2!\" , \"Function 2\" ) -- prints \"Number 2!\"","title":"State.bind"},{"location":"Api/#stateset","text":"State.set(state: any, type: string?) Sets the current state, it will also call the current observer with the new state. If a type is given, it will only call functions bound to that type. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Hello world\" ) print ( state . get ()) -> \"Hello world!\"","title":"State.set"},{"location":"Api/#stateget","text":"State.get(): any Returns the current set state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Whats up?\" ) print ( state . get () == \"Whats up?\" ) -> true","title":"State.get"},{"location":"Api/#strategy","text":"Have you ever had different changing selections that require a specific function? With Strategy you register functions with a specific name, the later set the strategy and when it's called it will execute the function with the corresponding name. Especially useful for changing powers.","title":"Strategy"},{"location":"Api/#strategynew","text":"Strategy.new(handles: {[string]: function}, start: string): Strategy Creates a new strategy. If start isnt given it will defualt to the first index. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) Strategy . new () -- Or Strategy ({ Name = function () end }, \"Name\" )","title":"Strategy.new"},{"location":"Api/#strategyadd","text":"Strategy.add(handler: function, name: string) Adds a handler to the list of handlers in the strategy. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () end , \"Name\" )","title":"Strategy.add"},{"location":"Api/#strategyset","text":"Strategy.set(name: string | State) Sets the current strategy. State If a state is given, it will get the current state and set that as the strategy, and NOT update the strategy when the state updates. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local State = require ( lib . State ) local strategy = Strategy . new () strategy . add ( function ( arg ) print ( arg ) end , \"Hello\" ) strategy . set ( \"Hello\" ) -- Is the same as local state = State . new () state . set ( \"Hello\" ) strategy . set ( state )","title":"Strategy.set"},{"location":"Api/#strategycall","text":"Strategy.call(...any): any Calls the current set strategy with given args. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () return 1 + 1 end , \"Plus\" ) strategy . set ( \"Plus\" ) print ( strategy . call ()) -> 2","title":"Strategy.call"},{"location":"Getting_Started/","text":"Basics Ro-Lib has java-script-like syntax. It's divided up into smaller sub-modules that are easy to use. It has a lot of modules, so that will be at least one that's useful for you. If you are still unsure here's something for you. Bad code local function FistAttack () -- ... end local function KickAttack () -- ... end local function MagicAttack () -- ... end local selected = \"Fist\" local function Attack (...) if selected == \"Fist\" then FistAttack (...) elseif selected == \"Kick\" then KickAttack (...) elseif selected == \"Magic\" then MagicAttack (...) else warn ( \"Could not find Attack with name: \" .. selected ) end end Good code local Command = require ( lib . Command ) local command = Command . new ({ Fist = function () -- ... end , Kick = function () -- ... end , Magic = function () -- ... end , }) local selected = \"Fist\" local function Attack (...) command . execute ( selected , ...) end Patterns Ro-Lib has every pattern you would want, and there's a lot. So here's a list with all patterns and their uses. Method Description Use Chain Chain allows you to pass checks along a chain Good for auth and checking inputs Command Command allows you to register and call functions Works weel for enemy systeams and components Factory Factory is used when for constructing classes When you have need to create many classes Observer Observer can be used instead of querying Makes events a lot better to use Singleton Singletong for when you only need one instance of a class Useful for services, when you only wanr one instance State State can be used for changing and reactive variables When you have constantly changing values Strategy Strategy when you have a family of callbacks to pick Best with abilityis, works will with Command and Factory Examples It's maybe hard to figure out when to use which patterns, so here are some examples to help. Ability When making abilities it can be best if they are modular and short. Here's it best to use Strategy and Factory to construct and use abilities. Placement System Placement systems can have lots of functionality and controls. So it can be hard managing them all. But using Observer to listen for events and Command to execute them can make it much easier. Admin auth For auth, the chain of responsibility (scary name) is the best choice. The chain can help clear up if statements. Button state Of course, you should use state for state management. Round manager You should use singleton for round management, you wouldn't want two have to manager or two rounds in the same place.","title":"Getting Started"},{"location":"Getting_Started/#basics","text":"Ro-Lib has java-script-like syntax. It's divided up into smaller sub-modules that are easy to use. It has a lot of modules, so that will be at least one that's useful for you. If you are still unsure here's something for you. Bad code local function FistAttack () -- ... end local function KickAttack () -- ... end local function MagicAttack () -- ... end local selected = \"Fist\" local function Attack (...) if selected == \"Fist\" then FistAttack (...) elseif selected == \"Kick\" then KickAttack (...) elseif selected == \"Magic\" then MagicAttack (...) else warn ( \"Could not find Attack with name: \" .. selected ) end end Good code local Command = require ( lib . Command ) local command = Command . new ({ Fist = function () -- ... end , Kick = function () -- ... end , Magic = function () -- ... end , }) local selected = \"Fist\" local function Attack (...) command . execute ( selected , ...) end","title":"Basics"},{"location":"Getting_Started/#patterns","text":"Ro-Lib has every pattern you would want, and there's a lot. So here's a list with all patterns and their uses. Method Description Use Chain Chain allows you to pass checks along a chain Good for auth and checking inputs Command Command allows you to register and call functions Works weel for enemy systeams and components Factory Factory is used when for constructing classes When you have need to create many classes Observer Observer can be used instead of querying Makes events a lot better to use Singleton Singletong for when you only need one instance of a class Useful for services, when you only wanr one instance State State can be used for changing and reactive variables When you have constantly changing values Strategy Strategy when you have a family of callbacks to pick Best with abilityis, works will with Command and Factory","title":"Patterns"},{"location":"Getting_Started/#examples","text":"It's maybe hard to figure out when to use which patterns, so here are some examples to help. Ability When making abilities it can be best if they are modular and short. Here's it best to use Strategy and Factory to construct and use abilities. Placement System Placement systems can have lots of functionality and controls. So it can be hard managing them all. But using Observer to listen for events and Command to execute them can make it much easier. Admin auth For auth, the chain of responsibility (scary name) is the best choice. The chain can help clear up if statements. Button state Of course, you should use state for state management. Round manager You should use singleton for round management, you wouldn't want two have to manager or two rounds in the same place.","title":"Examples"},{"location":"Installation/","text":"Installation I recommend using Rojo, as its where the power of Ro-Lib really shines. Its also best used with git. Also, you should update the module to new versions regularly. Roblox Studio: Get the Module from the Library or from github realeases . Place the Module within ReplicatedStorage. Rojo workflow: Download the Ro-Lib from the latest release . Extract the Module from the zipped file. Place the Module in ReplicatedStorage. Git workflow: Run git submodule add https://github.com/HawDevelopment/Ro-Lib.git Point the Submodule folder to ReplicatedStorage using Rojo.","title":"Installation"},{"location":"Installation/#installation","text":"I recommend using Rojo, as its where the power of Ro-Lib really shines. Its also best used with git. Also, you should update the module to new versions regularly. Roblox Studio: Get the Module from the Library or from github realeases . Place the Module within ReplicatedStorage. Rojo workflow: Download the Ro-Lib from the latest release . Extract the Module from the zipped file. Place the Module in ReplicatedStorage. Git workflow: Run git submodule add https://github.com/HawDevelopment/Ro-Lib.git Point the Submodule folder to ReplicatedStorage using Rojo.","title":"Installation"}]}