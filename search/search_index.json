{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ro-Lib Ro-Lib helps and encourages developers to use streamline design patterns in their code. It has all the things you need to make better and more performant games. Start here: Getting Started","title":"Home"},{"location":"#ro-lib","text":"Ro-Lib helps and encourages developers to use streamline design patterns in their code. It has all the things you need to make better and more performant games. Start here: Getting Started","title":"Ro-Lib"},{"location":"Api/","text":"lib Houses all the components of Ro-Lib. Contains: Chain Command Factory Observer Singleton State Strategy All patterns are classes. When calling a method you should use . instead of : -- DONT chain : add () state : set () Strategy . new () -- DO chain . set () state . set () Strategy () Chain First, add handlers to the chain. Each handler should return a boolean if it succeeds. Then when executing, it calls each handler one step at a time. If one returns false, it will warn and stop. Chain or chain of responsibility is used often for auth and guard statements. Chain.new Chain.new(chain: {[number]: function}?, shouldWarn: boolean?): Chain Creates a new chain. if shouldWarn is set to true it will warn on fail. Defualts to false. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain1 = Chain () -- Or local chain2 = Chain ({ function () end , }) Chain.add Chain.add(handler: function, index: number?): self Adds a new handler to the chain. The handler function should return a boolean. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () chain . add ( function () print ( \"Hello world!\" ) end ) -- When the chain is called it will print! Chain.execute Chain.execute(...any): boolean Executes the current chain, returns false on fail. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () local res = true chain . add ( function () res = false -- Se we dont get a warn return true end ) -- You could use chain() here chain . execute () print ( res ) -> false Command Register functions and then later call them by name. Use when you have lots of functions bound to one object. Command.new Command.new(commands: {[string]: function}?): Command Creates a new command. Command handlers are just a regular function. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) Command . new () -- Or Command ({ Name = function end }) Command.add Command.add(command: function, name: string) Adds a new handler to the command. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function () print ( \"Hello world!\" ) end , \"Hello\" ) -- When the Hello handler is called it will print! Command.execute Command.execute(name: string, ...any): any Calls the specified handler. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function ( arg ) print ( arg ) end , \"Hello\" ) command . execute ( \"Hello\" , \"Hello world!\" ) Factory Create an enum with corresponding name and function, and start creating classes at your will. This is what a defualt factory looks like: local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Support = 1 , Ticket = 2 , } local funcs = { Support = function () print ( \"Support!\" ) end , Ticket = function () print ( \"Ticket!\" ) end , } local factory = Factory . new ( enum , funcs ) Factory.new Factory.new(enum: {[string]: number}, factories: {[string]: function}): Factory Creates a new factory Factory functions should only modify the table given to them. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Dev = 1 , Mod = 2 , } local funcs = { Dev = function ( class ) print ( \"Develper!\" ) class . Name = \"Developer\" end , Mod = function ( class ) print ( \"Moderator!\" ) class . Name = \"Moderator\" end , } Factory . new ( enum , funcs ) Factory.create Factory.create(type: string | number, ...any) Creates a new class, using the specified function. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Dev = 1 , Mod = 2 , }, { Dev = function ( class ) class . Name = \"Developer\" end , Mod = function ( class ) class . Name = \"Moderator\" end , }) factory . create ( \"Dev\" ) -> { Name = \"Developer\" } -- Or factory . create ( 2 ) -> { Name = \"Moderator\" } Factory.rule Factory.rule(rule: {[number]: function}?) Sets the current rules, useful when having lots of similar agruments. The rules are just a table, each index will be called with argument of that index and should return true or false. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Hello = 1 }, { Hello = function ( class , name ) class . Message = \"Hello, \" .. name end , }) factory . rule ({ Factory . Type . string , }) -- Or you can use t by osyrisrblx: https://github.com/osyrisrblx/t factory . rule ({ t . string , }) -- Will error factory . create ( 1 , 10 ) factory . create ( 1 , nil ) factory . create ( 1 , workspace ) -- WON'T error factory . create ( 1 , \"HawDevelopment\" ) factory . create ( 1 , \"Elttob\" ) factory . create ( 1 , \"Berezaa\" ) Factory.base Factory.base(base: {[string]: any}) Sets the current base. A base is just the base class of any class created. You can also use Factory.Argument for linking arguments to the base. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Test = 1 }, { Test = function ( class ) -- Wont do anything end , }) factory . base ({ Name = Factory . Argument ( 1 ), Age = 13 , Skill = \"Scripting\" , }) -- Base can be used for repetative things factory . create ( 1 , \"HawDevelopment\" ) -> { Name = \"HawDevelopment\" , Age = 13 , Skill = \"Scripting\" } Observer You probably know Signals. Observers work mostly in the same way, the only difference is that you have many \"watchers\" bound to one observer, and you can have many underlying types. Types are like sub observer. So this is what a regular observer could look like: function function Sub: function function Observer.new Observer.new(watcher: {[any]: function}?): Observer Creates a new observer. A watcher is a function that will be called when the observer is fires. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) Observer . new () -- Or Observer ({ function () end , }) Observer.add Observer.add(watcher: function, type: string?) Adds a new watcher, you can also give it a type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () end ) -- Or observer . add ( function () end , \"Sub\" ) Observer.fire Observer.fire(type: string | \"All\" | nil, ...any) Fires the observer, if a type is given that isnt \"All\" it will only call watchers of that type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () print ( \"1\" ) end ) observer . add ( function () print ( \"2\" ) end , \"Sub\" ) observer . fire () -- \"1\" will print observer . fire ( \"Sub\" ) -- \"2\" will print Singleton Would you need more than one round? Using singleton you can create one class and then use it all over your program, no need to check if it exists. It doesn't create the class before you call the get method for the first time. Singleton.new Singleton.new(constructor: function | table): Singleton Creates a new singleton. The constructor can be a function or a class with a .new function, should return the value to be set as the singleton value. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) Singleton . new ( function () end ) -- Or Singleton ({ new = function () end }) Singleton.get Singleton.get(): any Gets the current storring object of the singleton, if it hasnt been created it will call the constructor. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) -- Havent been creating so it calls the constructor local ret = singleton . get () -- Returns the same table print ( ret == singleton . get ()) -> true Singleton.destroy Singleton.destroy() Destroys the current object stored. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) local ret = singleton . get () singleton . destroy () print ( ret == singleton . get ()) -> false State Sometimes it can be hard to manage player state. State.new State.new(defualt: any?, observer: Observer): State Creates a new state. If an obsever is given, it will be used instead of creating a new one. The observer of the state will be called when a new state has been set. local lib = require ( path . to . lib ) local State = require ( lib . State ) State . new () -- Or State ( \"Hello\" , Observer . new ()) State.observer State.observer(observer: Observer) Sets the current observer. local lib = require ( path . to . lib ) local State = require ( lib . State ) local Observer = require ( lib . Observer ) local state = State . new () state . observer ( Observer . new ()) State.bind State.bind(callback: function, type: string?) Binds the callback to the internal observer of the state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . bind ( function ( arg ) print ( arg ) end ) state . set ( \"Hello world\" ) -- prints \"Hello world!\" -- You can also bind to a specific type state . bind ( function ( arg ) print ( arg ) end , \"Function 2\" ) state . set ( \"Number 2!\" , \"Function 2\" ) -- prints \"Number 2!\" State.set State.set(state: any, type: string?) Sets the current state. It will also call the current observer with the new state. If a type is given, it will only call functions bound to that type in the observer. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Hello world\" ) print ( state . get ()) -> \"Hello world!\" State.get State.get(): any Returns the current set state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Whats up?\" ) print ( state . get () == \"Whats up?\" ) -> true Strategy Have you ever had different changing selections that require a specific function? With Strategy you register functions with a specific name, then later set it as the strategy and then execute the function at will. Especially useful for changing powers and abilities. Strategy.new Strategy.new(handles: {[string]: function}, start: string?): Strategy Creates a new strategy. If start is given it will set the index to it. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) Strategy . new () -- Or Strategy ({ Name = function () end }, \"Name\" ) Strategy.add Strategy.add(handler: function, name: string) Adds the handler to the list of handlers in the strategy. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () end , \"Name\" ) Strategy.set Strategy.set(name: string | State) Sets the current strategy. State If a state is given, it will get the current state and set that as the strategy, and NOT update the strategy when the state updates. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local State = require ( lib . State ) local strategy = Strategy . new () strategy . add ( function ( arg ) print ( arg ) end , \"Hello\" ) strategy . set ( \"Hello\" ) -- Is the same as local state = State . new () state . set ( \"Hello\" ) strategy . set ( state ) Strategy.call Strategy.call(...any): any Calls the current set strategy with given args. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () return 1 + 1 end , \"Plus\" ) strategy . set ( \"Plus\" ) print ( strategy . call ()) -> 2","title":"Api"},{"location":"Api/#lib","text":"Houses all the components of Ro-Lib. Contains: Chain Command Factory Observer Singleton State Strategy All patterns are classes. When calling a method you should use . instead of : -- DONT chain : add () state : set () Strategy . new () -- DO chain . set () state . set () Strategy ()","title":"lib"},{"location":"Api/#chain","text":"First, add handlers to the chain. Each handler should return a boolean if it succeeds. Then when executing, it calls each handler one step at a time. If one returns false, it will warn and stop. Chain or chain of responsibility is used often for auth and guard statements.","title":"Chain"},{"location":"Api/#chainnew","text":"Chain.new(chain: {[number]: function}?, shouldWarn: boolean?): Chain Creates a new chain. if shouldWarn is set to true it will warn on fail. Defualts to false. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain1 = Chain () -- Or local chain2 = Chain ({ function () end , })","title":"Chain.new"},{"location":"Api/#chainadd","text":"Chain.add(handler: function, index: number?): self Adds a new handler to the chain. The handler function should return a boolean. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () chain . add ( function () print ( \"Hello world!\" ) end ) -- When the chain is called it will print!","title":"Chain.add"},{"location":"Api/#chainexecute","text":"Chain.execute(...any): boolean Executes the current chain, returns false on fail. local lib = require ( path . to . lib ) local Chain = require ( lib . Chain ) local chain = Chain () local res = true chain . add ( function () res = false -- Se we dont get a warn return true end ) -- You could use chain() here chain . execute () print ( res ) -> false","title":"Chain.execute"},{"location":"Api/#command","text":"Register functions and then later call them by name. Use when you have lots of functions bound to one object.","title":"Command"},{"location":"Api/#commandnew","text":"Command.new(commands: {[string]: function}?): Command Creates a new command. Command handlers are just a regular function. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) Command . new () -- Or Command ({ Name = function end })","title":"Command.new"},{"location":"Api/#commandadd","text":"Command.add(command: function, name: string) Adds a new handler to the command. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function () print ( \"Hello world!\" ) end , \"Hello\" ) -- When the Hello handler is called it will print!","title":"Command.add"},{"location":"Api/#commandexecute","text":"Command.execute(name: string, ...any): any Calls the specified handler. local lib = require ( path . to . lib ) local Command = require ( lib . Command ) local command = Command . new () command . add ( function ( arg ) print ( arg ) end , \"Hello\" ) command . execute ( \"Hello\" , \"Hello world!\" )","title":"Command.execute"},{"location":"Api/#factory","text":"Create an enum with corresponding name and function, and start creating classes at your will. This is what a defualt factory looks like: local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Support = 1 , Ticket = 2 , } local funcs = { Support = function () print ( \"Support!\" ) end , Ticket = function () print ( \"Ticket!\" ) end , } local factory = Factory . new ( enum , funcs )","title":"Factory"},{"location":"Api/#factorynew","text":"Factory.new(enum: {[string]: number}, factories: {[string]: function}): Factory Creates a new factory Factory functions should only modify the table given to them. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local enum = { Dev = 1 , Mod = 2 , } local funcs = { Dev = function ( class ) print ( \"Develper!\" ) class . Name = \"Developer\" end , Mod = function ( class ) print ( \"Moderator!\" ) class . Name = \"Moderator\" end , } Factory . new ( enum , funcs )","title":"Factory.new"},{"location":"Api/#factorycreate","text":"Factory.create(type: string | number, ...any) Creates a new class, using the specified function. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Dev = 1 , Mod = 2 , }, { Dev = function ( class ) class . Name = \"Developer\" end , Mod = function ( class ) class . Name = \"Moderator\" end , }) factory . create ( \"Dev\" ) -> { Name = \"Developer\" } -- Or factory . create ( 2 ) -> { Name = \"Moderator\" }","title":"Factory.create"},{"location":"Api/#factoryrule","text":"Factory.rule(rule: {[number]: function}?) Sets the current rules, useful when having lots of similar agruments. The rules are just a table, each index will be called with argument of that index and should return true or false. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Hello = 1 }, { Hello = function ( class , name ) class . Message = \"Hello, \" .. name end , }) factory . rule ({ Factory . Type . string , }) -- Or you can use t by osyrisrblx: https://github.com/osyrisrblx/t factory . rule ({ t . string , }) -- Will error factory . create ( 1 , 10 ) factory . create ( 1 , nil ) factory . create ( 1 , workspace ) -- WON'T error factory . create ( 1 , \"HawDevelopment\" ) factory . create ( 1 , \"Elttob\" ) factory . create ( 1 , \"Berezaa\" )","title":"Factory.rule"},{"location":"Api/#factorybase","text":"Factory.base(base: {[string]: any}) Sets the current base. A base is just the base class of any class created. You can also use Factory.Argument for linking arguments to the base. local lib = require ( path . to . lib ) local Factory = require ( lib . Factory ) local factory = Factory . new ({ Test = 1 }, { Test = function ( class ) -- Wont do anything end , }) factory . base ({ Name = Factory . Argument ( 1 ), Age = 13 , Skill = \"Scripting\" , }) -- Base can be used for repetative things factory . create ( 1 , \"HawDevelopment\" ) -> { Name = \"HawDevelopment\" , Age = 13 , Skill = \"Scripting\" }","title":"Factory.base"},{"location":"Api/#observer","text":"You probably know Signals. Observers work mostly in the same way, the only difference is that you have many \"watchers\" bound to one observer, and you can have many underlying types. Types are like sub observer. So this is what a regular observer could look like: function function Sub: function function","title":"Observer"},{"location":"Api/#observernew","text":"Observer.new(watcher: {[any]: function}?): Observer Creates a new observer. A watcher is a function that will be called when the observer is fires. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) Observer . new () -- Or Observer ({ function () end , })","title":"Observer.new"},{"location":"Api/#observeradd","text":"Observer.add(watcher: function, type: string?) Adds a new watcher, you can also give it a type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () end ) -- Or observer . add ( function () end , \"Sub\" )","title":"Observer.add"},{"location":"Api/#observerfire","text":"Observer.fire(type: string | \"All\" | nil, ...any) Fires the observer, if a type is given that isnt \"All\" it will only call watchers of that type. local lib = require ( path . to . lib ) local Observer = require ( lib . Observer ) local observer = Observer . new () observer . add ( function () print ( \"1\" ) end ) observer . add ( function () print ( \"2\" ) end , \"Sub\" ) observer . fire () -- \"1\" will print observer . fire ( \"Sub\" ) -- \"2\" will print","title":"Observer.fire"},{"location":"Api/#singleton","text":"Would you need more than one round? Using singleton you can create one class and then use it all over your program, no need to check if it exists. It doesn't create the class before you call the get method for the first time.","title":"Singleton"},{"location":"Api/#singletonnew","text":"Singleton.new(constructor: function | table): Singleton Creates a new singleton. The constructor can be a function or a class with a .new function, should return the value to be set as the singleton value. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) Singleton . new ( function () end ) -- Or Singleton ({ new = function () end })","title":"Singleton.new"},{"location":"Api/#singletonget","text":"Singleton.get(): any Gets the current storring object of the singleton, if it hasnt been created it will call the constructor. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) -- Havent been creating so it calls the constructor local ret = singleton . get () -- Returns the same table print ( ret == singleton . get ()) -> true","title":"Singleton.get"},{"location":"Api/#singletondestroy","text":"Singleton.destroy() Destroys the current object stored. local lib = require ( path . to . lib ) local Singleton = require ( lib . Singleton ) local singleton = Singleton . new ( function () return { Name = \"HawDevelopment\" } end ) local ret = singleton . get () singleton . destroy () print ( ret == singleton . get ()) -> false","title":"Singleton.destroy"},{"location":"Api/#state","text":"Sometimes it can be hard to manage player state.","title":"State"},{"location":"Api/#statenew","text":"State.new(defualt: any?, observer: Observer): State Creates a new state. If an obsever is given, it will be used instead of creating a new one. The observer of the state will be called when a new state has been set. local lib = require ( path . to . lib ) local State = require ( lib . State ) State . new () -- Or State ( \"Hello\" , Observer . new ())","title":"State.new"},{"location":"Api/#stateobserver","text":"State.observer(observer: Observer) Sets the current observer. local lib = require ( path . to . lib ) local State = require ( lib . State ) local Observer = require ( lib . Observer ) local state = State . new () state . observer ( Observer . new ())","title":"State.observer"},{"location":"Api/#statebind","text":"State.bind(callback: function, type: string?) Binds the callback to the internal observer of the state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . bind ( function ( arg ) print ( arg ) end ) state . set ( \"Hello world\" ) -- prints \"Hello world!\" -- You can also bind to a specific type state . bind ( function ( arg ) print ( arg ) end , \"Function 2\" ) state . set ( \"Number 2!\" , \"Function 2\" ) -- prints \"Number 2!\"","title":"State.bind"},{"location":"Api/#stateset","text":"State.set(state: any, type: string?) Sets the current state. It will also call the current observer with the new state. If a type is given, it will only call functions bound to that type in the observer. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Hello world\" ) print ( state . get ()) -> \"Hello world!\"","title":"State.set"},{"location":"Api/#stateget","text":"State.get(): any Returns the current set state. local lib = require ( path . to . lib ) local State = require ( lib . State ) local state = State . new () state . set ( \"Whats up?\" ) print ( state . get () == \"Whats up?\" ) -> true","title":"State.get"},{"location":"Api/#strategy","text":"Have you ever had different changing selections that require a specific function? With Strategy you register functions with a specific name, then later set it as the strategy and then execute the function at will. Especially useful for changing powers and abilities.","title":"Strategy"},{"location":"Api/#strategynew","text":"Strategy.new(handles: {[string]: function}, start: string?): Strategy Creates a new strategy. If start is given it will set the index to it. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) Strategy . new () -- Or Strategy ({ Name = function () end }, \"Name\" )","title":"Strategy.new"},{"location":"Api/#strategyadd","text":"Strategy.add(handler: function, name: string) Adds the handler to the list of handlers in the strategy. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () end , \"Name\" )","title":"Strategy.add"},{"location":"Api/#strategyset","text":"Strategy.set(name: string | State) Sets the current strategy. State If a state is given, it will get the current state and set that as the strategy, and NOT update the strategy when the state updates. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local State = require ( lib . State ) local strategy = Strategy . new () strategy . add ( function ( arg ) print ( arg ) end , \"Hello\" ) strategy . set ( \"Hello\" ) -- Is the same as local state = State . new () state . set ( \"Hello\" ) strategy . set ( state )","title":"Strategy.set"},{"location":"Api/#strategycall","text":"Strategy.call(...any): any Calls the current set strategy with given args. local lib = require ( path . to . lib ) local Strategy = require ( lib . Strategy ) local strategy = Strategy . new () strategy . add ( function () return 1 + 1 end , \"Plus\" ) strategy . set ( \"Plus\" ) print ( strategy . call ()) -> 2","title":"Strategy.call"},{"location":"Examples/","text":"Examples Sometimes it can be difficult to learn new libraries or understanding why to choose them. But no worry, I'm here to help! Heres some examples of regular code, and improved code made with Ro-Lib. Bad Code Taken from Vesteria levels module. function module . getEquipmentInfo ( itemBaseData ) if itemBaseData then local level = itemBaseData . level or itemBaseData . minLevel if level then local stat = getStatForLevel ( level ) local function sig ( x ) local e = 2.7182818284590452353602874713527 return 15 / ( 1 + e ^ ( - 1 * ( 0.25 * x - 9 ))) end local cost = 1.35 * module . getQuestGoldFromLevel ( level ) * level ^ ( 1 / 3 ) * math.max ( sig ( level ), 1 ) local rarity = itemBaseData . rarity or \"Common\" if rarity == \"Legendary\" then cost = cost * 2 elseif rarity == \"Rare\" then cost = cost * 1.5 end local modifierData if itemBaseData . equipmentSlot then if itemBaseData . equipmentSlot == 1 then local damage = stat cost = cost * 0.7 if rarity == \"Legendary\" then damage = damage + 10 elseif rarity == \"Rare\" then damage = damage + 5 end return { damage = math.ceil ( damage ); cost = math.floor ( cost ); } elseif itemBaseData . equipmentSlot == 11 then return { cost = math.floor ( cost * 0.6 )} else local statUpgrade local defense if itemBaseData . equipmentSlot == 8 then defense = stat if rarity == \"Legendary\" then defense = defense + 10 elseif rarity == \"Rare\" then defense = defense + 5 end cost = cost * 1 defense = defense * ( itemBaseData . defenseModifier or 1 ) elseif itemBaseData . equipmentSlot == 9 then defense = 0 cost = cost * 0.35 elseif itemBaseData . equipmentSlot == 2 then defense = 0 cost = cost * 0.5 local value = stat / 5 local distribution = itemBaseData . statDistribution if itemBaseData . minimumClass == \"hunter\" then distribution = distribution or { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"warrior\" then distribution = distribution or { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"mage\" then distribution = distribution or { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } end if distribution then modifierData = {} for stat , coefficient in pairs ( distribution ) do modifierData [ stat ] = math.floor ( value * coefficient ) end end end if defense then return { defense = math.ceil ( defense ); cost = math.floor ( cost ); modifierData = modifierData ; statUpgrade = statUpgrade } end return false end end end end return false end Good Code local lib = require ( game . ReplicatedStorage . lib ) function module . getEquipmentInfo ( itemBaseData ) assert ( itemBaseData , \"Expected item base data, got nil\" ) local level = itemBaseData . level or itemBaseData . minLevel if not level then return false end local stat = getStatForLevel ( level ) local function sig ( x ) local e = 2.7182818284590452353602874713527 return 15 / ( 1 + e ^ ( - 1 * ( 0.25 * x - 9 ))) end local cost = 1.35 * module . getQuestGoldFromLevel ( level ) * level ^ ( 1 / 3 ) * math.max ( sig ( level ), 1 ) local rarity = itemBaseData . rarity or \"Common\" if rarity == \"Legendary\" then cost = cost * 2 elseif rarity == \"Rare\" then cost = cost * 1.5 end local modifierData if itemBaseData . equipmentSlot then if itemBaseData . equipmentSlot == 1 then local damage = stat cost = cost * 0.7 if rarity == \"Legendary\" then damage = damage + 10 elseif rarity == \"Rare\" then damage = damage + 5 end return { damage = math.ceil ( damage ); cost = math.floor ( cost ); } elseif itemBaseData . equipmentSlot == 11 then return { cost = math.floor ( cost * 0.6 )} else local statUpgrade local defense if itemBaseData . equipmentSlot == 8 then defense = stat if rarity == \"Legendary\" then defense = defense + 10 elseif rarity == \"Rare\" then defense = defense + 5 end cost = cost * 1 defense = defense * ( itemBaseData . defenseModifier or 1 ) elseif itemBaseData . equipmentSlot == 9 then defense = 0 cost = cost * 0.35 elseif itemBaseData . equipmentSlot == 2 then defense = 0 cost = cost * 0.5 local value = stat / 5 local distribution = itemBaseData . statDistribution if itemBaseData . minimumClass == \"hunter\" then distribution = distribution or { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"warrior\" then distribution = distribution or { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"mage\" then distribution = distribution or { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } end if distribution then modifierData = {} for stat , coefficient in pairs ( distribution ) do modifierData [ stat ] = math.floor ( value * coefficient ) end end end if defense then return { defense = math.ceil ( defense ); cost = math.floor ( cost ); modifierData = modifierData ; statUpgrade = statUpgrade } end return false end end return false end","title":"Examples"},{"location":"Examples/#examples","text":"Sometimes it can be difficult to learn new libraries or understanding why to choose them. But no worry, I'm here to help! Heres some examples of regular code, and improved code made with Ro-Lib. Bad Code Taken from Vesteria levels module. function module . getEquipmentInfo ( itemBaseData ) if itemBaseData then local level = itemBaseData . level or itemBaseData . minLevel if level then local stat = getStatForLevel ( level ) local function sig ( x ) local e = 2.7182818284590452353602874713527 return 15 / ( 1 + e ^ ( - 1 * ( 0.25 * x - 9 ))) end local cost = 1.35 * module . getQuestGoldFromLevel ( level ) * level ^ ( 1 / 3 ) * math.max ( sig ( level ), 1 ) local rarity = itemBaseData . rarity or \"Common\" if rarity == \"Legendary\" then cost = cost * 2 elseif rarity == \"Rare\" then cost = cost * 1.5 end local modifierData if itemBaseData . equipmentSlot then if itemBaseData . equipmentSlot == 1 then local damage = stat cost = cost * 0.7 if rarity == \"Legendary\" then damage = damage + 10 elseif rarity == \"Rare\" then damage = damage + 5 end return { damage = math.ceil ( damage ); cost = math.floor ( cost ); } elseif itemBaseData . equipmentSlot == 11 then return { cost = math.floor ( cost * 0.6 )} else local statUpgrade local defense if itemBaseData . equipmentSlot == 8 then defense = stat if rarity == \"Legendary\" then defense = defense + 10 elseif rarity == \"Rare\" then defense = defense + 5 end cost = cost * 1 defense = defense * ( itemBaseData . defenseModifier or 1 ) elseif itemBaseData . equipmentSlot == 9 then defense = 0 cost = cost * 0.35 elseif itemBaseData . equipmentSlot == 2 then defense = 0 cost = cost * 0.5 local value = stat / 5 local distribution = itemBaseData . statDistribution if itemBaseData . minimumClass == \"hunter\" then distribution = distribution or { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"warrior\" then distribution = distribution or { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"mage\" then distribution = distribution or { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } end if distribution then modifierData = {} for stat , coefficient in pairs ( distribution ) do modifierData [ stat ] = math.floor ( value * coefficient ) end end end if defense then return { defense = math.ceil ( defense ); cost = math.floor ( cost ); modifierData = modifierData ; statUpgrade = statUpgrade } end return false end end end end return false end Good Code local lib = require ( game . ReplicatedStorage . lib ) function module . getEquipmentInfo ( itemBaseData ) assert ( itemBaseData , \"Expected item base data, got nil\" ) local level = itemBaseData . level or itemBaseData . minLevel if not level then return false end local stat = getStatForLevel ( level ) local function sig ( x ) local e = 2.7182818284590452353602874713527 return 15 / ( 1 + e ^ ( - 1 * ( 0.25 * x - 9 ))) end local cost = 1.35 * module . getQuestGoldFromLevel ( level ) * level ^ ( 1 / 3 ) * math.max ( sig ( level ), 1 ) local rarity = itemBaseData . rarity or \"Common\" if rarity == \"Legendary\" then cost = cost * 2 elseif rarity == \"Rare\" then cost = cost * 1.5 end local modifierData if itemBaseData . equipmentSlot then if itemBaseData . equipmentSlot == 1 then local damage = stat cost = cost * 0.7 if rarity == \"Legendary\" then damage = damage + 10 elseif rarity == \"Rare\" then damage = damage + 5 end return { damage = math.ceil ( damage ); cost = math.floor ( cost ); } elseif itemBaseData . equipmentSlot == 11 then return { cost = math.floor ( cost * 0.6 )} else local statUpgrade local defense if itemBaseData . equipmentSlot == 8 then defense = stat if rarity == \"Legendary\" then defense = defense + 10 elseif rarity == \"Rare\" then defense = defense + 5 end cost = cost * 1 defense = defense * ( itemBaseData . defenseModifier or 1 ) elseif itemBaseData . equipmentSlot == 9 then defense = 0 cost = cost * 0.35 elseif itemBaseData . equipmentSlot == 2 then defense = 0 cost = cost * 0.5 local value = stat / 5 local distribution = itemBaseData . statDistribution if itemBaseData . minimumClass == \"hunter\" then distribution = distribution or { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 1 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"warrior\" then distribution = distribution or { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } statUpgrade = { str = 1 ; dex = 0 ; int = 0 ; vit = 0 ; } elseif itemBaseData . minimumClass == \"mage\" then distribution = distribution or { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } statUpgrade = { str = 0 ; dex = 0 ; int = 1 ; vit = 0 ; } end if distribution then modifierData = {} for stat , coefficient in pairs ( distribution ) do modifierData [ stat ] = math.floor ( value * coefficient ) end end end if defense then return { defense = math.ceil ( defense ); cost = math.floor ( cost ); modifierData = modifierData ; statUpgrade = statUpgrade } end return false end end return false end","title":"Examples"},{"location":"Getting_Started/","text":"Basics Ro-Lib has java-script-like syntax. Ro-Lib is divided up into smaller sub-modules that are modular and easy to use. Heres a quik example of some Ro-Lib code improvements. Bad code local function FistAttack () -- ... end local function KickAttack () -- ... end local function MagicAttack () -- ... end local selected = \"Fist\" local function Attack (...) if selected == \"Fist\" then FistAttack (...) elseif selected == \"Kick\" then KickAttack (...) elseif selected == \"Magic\" then MagicAttack (...) else warn ( \"Could not find Attack with name: \" .. selected ) end end Good code local Command = require ( lib . Command ) local command = Command . new ({ Fist = function () -- ... end , Kick = function () -- ... end , Magic = function () -- ... end , }) local selected = \"Fist\" local function Attack (...) command . execute ( selected , ...) end Patterns Ro-Lib has every pattern you need. It can be hard finding the right pattern, so heres all the patterns with their uses. Method Description Use Chain Chain, pass checks along a chain Good for auth and guard statements Command Command, register and call functions Works well for enemy systems and components Factory Factory, constructing classes Creating lots of classes Observer Observer, observe instead of querying Signal data structures Singleton Singleton, create only one object Only creating one of a kind object State State, changing and reactive variables Changing values, or for things out of scope Strategy Strategy, family of callbacks to pick Abilities and weapons Examples Heres some examples for when to use the patterns. Ability When making abilities it's best if they are modular and short. Here's it's best to use Strategy and Factory to construct and use abilities. Placement System Placement systems can have a lot of functionality and controls. So it can be difficult to manage them all. Here it's best to use Observer for listening for events and Command to executing them. Admin auth Auth can have many if statements. It's here Chain really shines, helping clear up hundred lines of if statements. Button state State should be reactive, use State.","title":"Getting Started"},{"location":"Getting_Started/#basics","text":"Ro-Lib has java-script-like syntax. Ro-Lib is divided up into smaller sub-modules that are modular and easy to use. Heres a quik example of some Ro-Lib code improvements. Bad code local function FistAttack () -- ... end local function KickAttack () -- ... end local function MagicAttack () -- ... end local selected = \"Fist\" local function Attack (...) if selected == \"Fist\" then FistAttack (...) elseif selected == \"Kick\" then KickAttack (...) elseif selected == \"Magic\" then MagicAttack (...) else warn ( \"Could not find Attack with name: \" .. selected ) end end Good code local Command = require ( lib . Command ) local command = Command . new ({ Fist = function () -- ... end , Kick = function () -- ... end , Magic = function () -- ... end , }) local selected = \"Fist\" local function Attack (...) command . execute ( selected , ...) end","title":"Basics"},{"location":"Getting_Started/#patterns","text":"Ro-Lib has every pattern you need. It can be hard finding the right pattern, so heres all the patterns with their uses. Method Description Use Chain Chain, pass checks along a chain Good for auth and guard statements Command Command, register and call functions Works well for enemy systems and components Factory Factory, constructing classes Creating lots of classes Observer Observer, observe instead of querying Signal data structures Singleton Singleton, create only one object Only creating one of a kind object State State, changing and reactive variables Changing values, or for things out of scope Strategy Strategy, family of callbacks to pick Abilities and weapons","title":"Patterns"},{"location":"Getting_Started/#examples","text":"Heres some examples for when to use the patterns. Ability When making abilities it's best if they are modular and short. Here's it's best to use Strategy and Factory to construct and use abilities. Placement System Placement systems can have a lot of functionality and controls. So it can be difficult to manage them all. Here it's best to use Observer for listening for events and Command to executing them. Admin auth Auth can have many if statements. It's here Chain really shines, helping clear up hundred lines of if statements. Button state State should be reactive, use State.","title":"Examples"},{"location":"Installation/","text":"Installation Ro-Lib is simple to install, just place it in ReplicatedStorage. Roblox Studio: Get the Module from the Library or from github realeases . Place the Module within ReplicatedStorage. Rojo workflow: Download Ro-Lib from the latest release . Extract the Module from the zip file. Sync the folder in under ReplicatedStorage. Git workflow: Run git submodule add https://github.com/HawDevelopment/Ro-Lib.git Point the Submodule folder to ReplicatedStorage using Rojo.","title":"Installation"},{"location":"Installation/#installation","text":"Ro-Lib is simple to install, just place it in ReplicatedStorage. Roblox Studio: Get the Module from the Library or from github realeases . Place the Module within ReplicatedStorage. Rojo workflow: Download Ro-Lib from the latest release . Extract the Module from the zip file. Sync the folder in under ReplicatedStorage. Git workflow: Run git submodule add https://github.com/HawDevelopment/Ro-Lib.git Point the Submodule folder to ReplicatedStorage using Rojo.","title":"Installation"}]}